from typing import Iterable, TypeVar, Callable, Optional, overload

K = TypeVar('K')
V = TypeVar('V')
E = TypeVar('E')
R = TypeVar('R')

identity = lambda x:x

def take_while(iterable:Iterable[E],predicate:Callable[[E],bool]) -> Iterable[E]: ...       
def drop_while(iterable:Iterable[E],predicate:Callable[[E],bool]) -> Iterable[E]: ...
def aleatorios(n:int,a:int,b:int) -> Iterable[int]: ...
def iterate(initial:E, operator:Callable[[E],E], predicate:Callable[[E],bool]=lambda _:True) -> Iterable[E]: ...     
def all_pairs(n:int,m:int,n0:int = 0, m0:int= 0)-> Iterable[tuple[int,int]]: ... 
def distinct(iterable:Iterable[E])->Iterable[E]: ...          
def all_different(iterable:Iterable[E])->bool: ...           
def limit(iterable:Iterable[E],limit:int) -> Iterable[E]: ...      
def count_if(iterable:Iterable[E],predicate:Callable[[E],bool]=lambda _:True)->int: ...
def first(iterable:Iterable[E], p:Callable[[E],bool]=lambda _:True) -> Optional[E]: ...
def first_and_rest(iterable:Iterable[E]) -> Optional[tuple[E,Iterable[E]]]: ...
def first_and_last(iterable:Iterable[E])->Optional[tuple[E,E]]: ...
def first_index_true(iterable:Iterable[bool],default:int=-1)->int: ...
def first_index_if(iterable:Iterable[E],predicate:Callable[[E],bool],default:int=-1)->int: ...
def first_index_with_elem(iterable:Iterable[E],elem:E,default:int=-1)->int: ...
@overload
def flat_map(iterable:Iterable[Iterable[E]]) -> Iterable[E]: ...
@overload   
def flat_map(iterable:Iterable[E],key:Callable[[E],Iterable[R]]) -> Iterable[R]: ...    
@overload
def flat_map_enumerate(iterable:enumerate[Iterable[E]]) -> Iterable[tuple[int,E]]: ...
@overload   
def flat_map_enumerate(iterable:enumerate[E],key:Callable[[E],Iterable[R]]) -> Iterable[tuple[int,R]]: ...            
def flat(e: E | Iterable[E]) -> Iterable[E]: ...
def str_iter(iterable:Iterable[E],sep:str=',',prefix:str='{',suffix:str='}',key:Callable[[E],str]=str)->str:...
@overload
def grouping_reduce(iterable:Iterable[E],key:Callable[[E],K],op:Callable[[V,V],V],value:Callable[[E],V]=identity) -> dict[K,V]: ...
@overload
def grouping_reduce(iterable:Iterable[E],key:Callable[[E],K],op:Callable[[V,V],V],value:Callable[[E],V]=identity,andThen:Optional[Callable[[V],R]]=None) -> dict[K,R]: ...
@overload
def grouping_list(iterable:Iterable[E],key:Callable[[E],K],value:Callable[[E],V]=identity) -> dict[K,list[V]]: ...
@overload
def grouping_list(iterable:Iterable[E],key:Callable[[E],K],value:Callable[[E],V]=identity,andThen:Optional[Callable[[list[V]],R]]=None) -> dict[K,R]: ...   
@overload
def grouping_set(iterable:Iterable[E],key:Callable[[E],K],value:Callable[[E],V]=identity) -> dict[K,set[V]]: ...
@overload
def grouping_set(iterable:Iterable[E],key:Callable[[E],K],value:Callable[[E],V]=identity,andThen:Optional[Callable[[set[V]],R]]=None) -> dict[K,R]: ...
def groups_size(iterable:Iterable[E],key:Callable[[E],K]=identity,value:Callable[[E],int]=lambda _:1) -> dict[K,int]: ...
def join(s1:Iterable[E],s2:Iterable[R],key1:Callable[[E],K],key2:Callable[[R],K])->Iterable[tuple[E,R]]:...